{"mode":"editor","version":1,"windowDimensions":{"x":4,"y":23,"width":1260,"height":777,"maximized":false},"grammars":{"deserializer":"GrammarRegistry","grammarOverridesByPath":{}},"project":{"paths":["/Users/benfallon/Desktop/DBC/phase_1/zweek_one/friday/sudoku-challenge"],"buffers":[{"text":"require 'byebug'\n\nclass Sudoku\n  def initialize(board_string)\n    @board_string = board_string\n  end\n\n  def string_to_array\n    full_board_array = @board_string.split('')\n    @full_board = Array.new(9) { full_board_array.shift(9) }\n  end\n\n  def finished? count = 0 @full_board.each do |row| if row.any? {|space| space == \"-\"}\n  then count += 1 end end return true if count == 0 end\n\n  def empty?(cell)\n    cell == \"-\" ? true : false\n  end\n\n  # def create_squares(row_1, row_2, row_3, cell_index_1, cell_index_2, cell_index_3)\n  #   square = []\n  #   square << @full_board[row_1][cell_index_1]\n  #   square << @full_board[row_2][cell_index_1]\n  #   square << @full_board[row_3][cell_index_1]\n  #   square << @full_board[row_1][cell_index_2]\n  #   square << @full_board[row_2][cell_index_2]\n  #   square << @full_board[row_3][cell_index_2]\n  #   square << @full_board[row_1][cell_index_3]\n  #   square << @full_board[row_2][cell_index_3]\n  #   square << @full_board[row_3][cell_index_3]\n  #   return square\n  # end\n  def create_boxes_array(row1, row2, row3)\n\n   new_array = row1.zip(row2, row3)\n   sliced_new_array = new_array.each_slice(3).to_a\n   box = sliced_new_array.map! do |sub_array|\n     sub_array.flatten\n   end\n   return box\n  end\n\n\n  def row_check(row_index, array_of_possibilities)\n    @full_board[row_index].each do |cell_contents|\n      array_of_possibilities.each_with_index do |options, options_index|\n        if options == cell_contents\n          array_of_possibilities.delete_at(options_index)\n        end\n      end\n    end\n    return array_of_possibilities\n  end\n\n  def column_check(row_index, array_of_possibilities)\n    all_columns = @full_board.transpose\n    column = all_columns[row_index]\n    column.each do |cell_contents|\n      array_of_possibilities.each_with_index do |options,options_index|\n        if options == cell_contents\n          array_of_possibilities.delete_at(options_index)\n        end\n      end\n    end\n    return array_of_possibilities\n  end\n\n  def square_check (square_array, array_of_possibilities)\n    square_array.each do |square_values|\n      array_of_possibilities.each_with_index do |options, options_index|\n        if options == square_values\n          array_of_possibilities.delete_at(options_index)\n        end\n      end\n    end\n    return array_of_possibilities\n  end\n\n  def solve\n    string_to_array\n    until finished?\n      @full_board.each_with_index do |row_content, row_index|\n        row_content.each_with_index do |cell_content, cell_index|\n          if empty?(cell_content)\n            if row_index == 0\n              row_1_index = 0\n              row_2_index = 1\n              row_3_index = 2\n            elsif row_index == 1\n              row_1_index = 0\n              row_2_index = 1\n              row_3_index = 2\n            elsif row_index == 2\n              row_1_index = 0\n              row_2_index = 1\n              row_3_index = 2\n            elsif row_index == 3\n              row_1_index = 3\n              row_2_index = 4\n              row_3_index = 5\n            elsif row_index == 4\n              row_1_index = 3\n              row_2_index = 4\n              row_3_index = 5\n            elsif row_index == 5\n              row_1_index = 3\n              row_2_index = 4\n              row_3_index = 5\n            elsif row_index == 6\n              row_1_index = 6\n              row_2_index = 7\n              row_3_index = 8\n            elsif row_index == 7\n              row_1_index = 6\n              row_2_index = 7\n              row_3_index = 8\n            elsif row_index == 8\n              row_1_index = 6\n              row_2_index = 7\n              row_3_index = 8\n            end\n\n            if cell_index == 0\n              cell_index_1 = 0\n              cell_index_2 = 1\n              cell_index_3 = 2\n            elsif cell_index == 1\n              cell_index_1 = 0\n              cell_index_2 = 1\n              cell_index_3 = 2\n            elsif cell_index == 2\n              cell_index_1 = 0\n              cell_index_2 = 1\n              cell_index_3 = 2\n            elsif cell_index == 3\n              cell_index_1 = 3\n              cell_index_2 = 4\n              cell_index_3 = 5\n            elsif cell_index == 4\n              cell_index_1 = 3\n              cell_index_2 = 4\n              cell_index_3 = 5\n            elsif cell_index == 5\n              cell_index_1 = 3\n              cell_index_2 = 4\n              cell_index_3 = 5\n            elsif cell_index == 6\n              cell_index_1 = 6\n              cell_index_2 = 7\n              cell_index_3 = 8\n            elsif cell_index == 7\n              cell_index_1 = 6\n              cell_index_2 = 7\n              cell_index_3 = 8\n            elsif cell_index == 8\n              cell_index_1 = 6\n              cell_index_2 = 7\n              cell_index_3 = 8\n            end\n            square = create_squares(row_1_index, row_2_index, row_3_index, cell_index_1, cell_index_2, cell_index_3)\n            possibilities = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]\n            modified_possibilities = row_check(row_index, possibilities)\n            modified_possibilities_2 = column_check(cell_index, modified_possibilities)\n            modified_possibilities_3 = square_check(square, modified_possibilities_2)\n            if modified_possibilities_3.length == 1\n              new_number = modified_possibilities[0]\n              @full_board[row_index][cell_index] = new_number\n            end\n          end\n        end\n      end\n    end\n  end\n\n  def board\n    p @full_board\n  end\n\n  # Returns a string representing the current state of the board\n  def to_s\n  end\nend\n\n\n game = Sudoku.new(\"6-873----2-----46-----6482--8---57-19--618--4-31----8-86-2---39-5----1--1--4562--\")\n game.solve\n game.board\n","markerStore":{"nextMarkerId":12,"markersById":{"0":{"range":{"start":{"row":6,"column":0},"end":{"row":6,"column":0}},"properties":{"type":"selection","editorId":8,"goalScreenRange":null,"preserveFolds":true,"autoscroll":false},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true},"1":{"range":{"start":{"row":12,"column":0},"end":{"row":14,"column":0}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"never","maintainHistory":false},"3":{"range":{"start":{"row":12,"column":0},"end":{"row":14,"column":0}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"never","maintainHistory":false}},"version":2},"history":{"version":3,"nextCheckpointId":2,"undoStack":[{"type":"group-start","snapshot":{"0":{"range":[[14,29],[14,29]],"properties":{"type":"selection","editorId":8,"goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true}}},{"type":"change","content":{"oldRange":[[12,0],[19,5]],"newRange":[[12,0],[13,55]],"oldText":"  def finished?\n    count = 0\n    @full_board.each do |row|\n      if row.any? {|space| space == \"-\"} then count += 1\n      end\n    end\n    return true if count == 0\n  end","newText":"  def finished? count = 0 @full_board.each do |row| if row.any? {|space| space == \"-\"}\n  then count += 1 end end return true if count == 0 end"}},{"type":"group-end","snapshot":{"0":{"range":[[13,55],[13,55]],"properties":{"type":"selection","editorId":8,"goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true}}}],"redoStack":[]},"encoding":"utf8","filePath":"/Users/benfallon/Desktop/DBC/phase_1/zweek_one/friday/sudoku-challenge/source/sudoku.rb","digestWhenLastPersisted":"15ee6948769b32addcd66b89c28f0b225b992efc","preferredLineEnding":null,"deserializer":"TextBuffer","version":2},{"text":"require_relative 'sudoku'\n\n# The sudoku puzzles that your program will solve can be found\n# in the sudoku_puzzles.txt file.\n#\n# Currently, Line 16 defines the variable board_string to equal\n# the first puzzle (i.e., the first line in the .txt file).\n# After your program can solve this first puzzle, edit\n# the code below, so that the program tries to solve\n# all of the puzzles.\n#\n# Remember, the file has newline characters at the end of each line,\n# so we call String#chomp to remove them.\n\n\nboard_string = File.readlines('sudoku_puzzles.txt').first.chomp\n\ngame = Sudoku.new(board_string)\ngame.solve\nputs game","markerStore":{"nextMarkerId":2,"markersById":{"0":{"range":{"start":{"row":19,"column":9},"end":{"row":19,"column":9}},"properties":{"type":"selection","editorId":12,"goalScreenRange":null,"preserveFolds":true},"reversed":true,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true},"1":{"range":{"start":{"row":19,"column":0},"end":{"row":19,"column":9}},"properties":{},"reversed":false,"tailed":true,"valid":true,"invalidate":"never","maintainHistory":false}},"version":2},"history":{"version":3,"nextCheckpointId":3,"undoStack":[{"type":"group-start","snapshot":{"0":{"range":[[20,0],[20,0]],"properties":{"type":"selection","editorId":12,"goalScreenRange":null,"preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true}}},{"type":"change","content":{"oldRange":[[19,9],[20,0]],"newRange":[[19,9],[19,9]],"oldText":"\n","newText":""}},{"type":"group-end","snapshot":{"0":{"range":[[19,9],[19,9]],"properties":{"type":"selection","editorId":12,"goalScreenRange":null,"preserveFolds":true},"reversed":true,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true}}}],"redoStack":[]},"encoding":"utf8","filePath":"/Users/benfallon/Desktop/DBC/phase_1/zweek_one/friday/sudoku-challenge/source/runner.rb","digestWhenLastPersisted":"69d02d4368b9e0a656e3119faa4e9d597ab93ca7","preferredLineEnding":null,"deserializer":"TextBuffer","version":2}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"id":3,"items":[{"id":8,"softTabs":true,"displayBuffer":{"id":9,"softWrapped":true,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/benfallon/Desktop/DBC/phase_1/zweek_one/friday/sudoku-challenge/source/sudoku.rb","largeFileMode":false,"deserializer":"TokenizedBuffer"},"largeFileMode":false,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":12,"softTabs":true,"displayBuffer":{"id":13,"softWrapped":true,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/benfallon/Desktop/DBC/phase_1/zweek_one/friday/sudoku-challenge/source/runner.rb","largeFileMode":false,"deserializer":"TokenizedBuffer"},"largeFileMode":false,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"}],"activeItemURI":"/Users/benfallon/Desktop/DBC/phase_1/zweek_one/friday/sudoku-challenge/source/sudoku.rb","focused":true,"flexScale":1,"deserializer":"Pane"},"activePaneId":3,"deserializer":"PaneContainer","version":1},"fullScreen":false,"packagesWithActiveGrammars":["language-ruby","language-hyperlink","language-todo"],"deserializer":"Workspace"},"packageStates":{"fuzzy-finder":{"/Users/benfallon/Desktop/DBC/phase_1/zweek_one/friday/sudoku-challenge/source/sudoku.rb":1445142273000,"/Users/benfallon/Desktop/DBC/phase_1/zweek_one/friday/sudoku-challenge/source/runner.rb":1445133316821},"metrics":{"sessionLength":9193160},"tabs":[{}],"tree-view":{"directoryExpansionStates":{"/Users/benfallon/Desktop/DBC/phase_1/zweek_one/friday/sudoku-challenge":{"isExpanded":true,"entries":{".git":{"isExpanded":false,"entries":{}},"source":{"isExpanded":true,"entries":{}}}}},"selectedPath":"/Users/benfallon/Desktop/DBC/phase_1/zweek_one/friday/sudoku-challenge/source/sudoku.rb","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}