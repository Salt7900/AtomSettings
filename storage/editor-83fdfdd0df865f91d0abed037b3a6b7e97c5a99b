{"mode":"editor","version":1,"windowDimensions":{"x":4,"y":23,"width":1260,"height":777,"maximized":false},"grammars":{"deserializer":"GrammarRegistry","grammarOverridesByPath":{}},"project":{"paths":["/Users/benfallon/Desktop/DBC/phase_2/week_4/wednesday/rest-controller-challenge"],"buffers":[{"text":"# REST Controller Challenge\n\n## Summary\nIn this challenge we'll learn the conventions around request types (e.g., GET and POST) and paths (e.g., `/dogs`) in a CRUD application.\n\n[CRUD][wikipedia crud] stands for create, read, update, and delete.  These are the basic behaviors for persisting data.  We insert new records into the database, read them from the database, update their values, and delete them from the database.  In order to trigger these behaviors in a web application, we need to make requests to specific routes: a route for inserting data into the database, a route for getting all the records from the database, a route for updating a record, etc.\n\n| Description                        | Behavior | Request Type | Request Path     |\n|------------------------------------|----------|--------------|------------------|\n| Insert a dog record                | Create   | POST         | `/dogs`          |\n| Select all dogs records            | Read     | GET          | `/dogs`          |\n| Select one dog record              | Read     | GET          | `/dogs/:id`      |\n| Form for creating a new dog record | Read     | GET          | `/dogs/new`      |\n| Form for editing a dog record      | Read     | GET          | `/dogs/:id/edit` |\n| Update a dog record                | Update   | PUT          | `/dogs/:id`      |\n| Delete a dog record                | Delete   | DELETE       | `/dogs/:id`      |\n*Table 1*.  Conventional request types and paths for CRUD behaviors (based on [table][railsguides routes table] in RailsGuides).\n\nImagine a dog adoption application with a `Dog` model. If a user wants to list a new dog for adoption, the user needs to navigate to the page with the form for providing information about the dog. Let's say that to get to the page with the form, the user clicks a \"List Dog\" link. Following convention, clicking that link should trigger a GET request to the path `/dogs/new`.  The response to that request would return the page with the form.  When the user completes the form and clicks the submit button, this should conventionally trigger a POST request to the path `/dogs`.  And there are conventions for the other behaviors as well (see Table 1).\n\nThese conventions are part of an approach to structuring an application known as [REST][wikipedia rest] (representational state transfer).  In this challenge we are going to refactor a working application whose developer did not follow REST-ful routing conventions.  We're going to update the application to follow routing conventions.\n\n\n### Defining Route Handlers\n```ruby\nget '/dogs/:id' do\n  # Implement route handler\nend\n\nput '/dogs/:id' do\n  # Implement route handler\nend\n\ndelete '/dogs/:id' do\n  #Implement route handler\nend\n```\n*Figure 1*. Defining route handlers for PUT and DELETE requests.\n\nWe can define route handlers for PUT and DELETE requests the same way that we define them for GET and POST request.  The method we use to define a handler (e.g, `:get` or `:put`) matches the request type, and we pass in the path and a block that says what to do when the request is made.  See how the request types and paths from Table 1 are translated into the route handlers in Figure 1.\n\n\n### Making PUT and DELETE Requests in Sinatra\nThere is a browser limitation that we need to work around.  Browsers make GET and POST requests.  In addition to these, we need to make PUT and DELETE requests.\n\n```HTML\n<form method=\"post\" action=\"dogs/<%= @dog.id %>\">\n  <input type=\"hidden\" name=\"_method\" value=\"put\">\n\n  <!-- continue form ... -->\n</form>\n```\n*Figure 2*. Adding a `_method` parameter with the value `\"put\"` to a `POST` request made from a form submission.\n\nWe can tell Sinatra to interpret a POST request as a PUT or DELETE request.  We do this by sending a parameter named `_method` along with the other data.  We set the value of this parameter to the name of one of the browser-unsupported request types (i.e., PUT or DELETE).  This can be done in a form by adding a hidden input (see Figure 2).\n\n\n## Releases\n### Pre-release:  Set up the Working Application\nWe'll begin with a functioning application, but we need to do some setup to get it working.  First, we need to create, migrate, and seed the database.\n\nOnce the database is setup, let's start the server, and explore the application.  It's a simple, one-resource CRUD application.  It's an app for signing up to sing karaoke.  Users submit their names and the title of the song they'll perform, and an entry is added to the list.  Entries can be edited and deleted.\n\n\n### Release 0:  Refactor Routes\nWe're going to refactor the routes in this application to follow REST-ful routing conventions.  Our application has all the behavior that it needs; we just need to refactor the code.\n\nThis refactor will involve updating our route handlers to match the conventional request types and paths.  We'll also need to update anywhere the old paths appear:  form actions, links, redirect paths, etc.\n\n\n## Conclusion\nWe've been following conventions for Ruby style, table and class names, etc.  Now we can add conventions for routing to the list.  Why would it be beneficial to follow REST-ful routing conventions?  How would following the conventions affect other developers on our project?\n\n\n[railsguides routes table]: http://guides.rubyonrails.org/routing.html#crud-verbs-and-actions\n[wikipedia crud]: https://en.wikipedia.org/wiki/Create,_read,_update_and_delete\n[wikipedia rest]: https://en.wikipedia.org/wiki/Representational_state_transfer\n","markerStore":{"nextMarkerId":5,"markersById":{"0":{"range":{"start":{"row":60,"column":0},"end":{"row":60,"column":0}},"properties":{"type":"selection","editorId":8,"goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true}},"version":2},"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/Users/benfallon/Desktop/DBC/phase_2/week_4/wednesday/rest-controller-challenge/README.md","digestWhenLastPersisted":"1bf853eacee49ce33f9a07b256fe75ba84315d6b","preferredLineEnding":null,"deserializer":"TextBuffer","version":2}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"id":3,"items":[{"id":8,"softTabs":true,"displayBuffer":{"id":9,"softWrapped":true,"scrollTop":1890,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/benfallon/Desktop/DBC/phase_2/week_4/wednesday/rest-controller-challenge/README.md","largeFileMode":false,"deserializer":"TokenizedBuffer"},"largeFileMode":false,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"}],"activeItemURI":"/Users/benfallon/Desktop/DBC/phase_2/week_4/wednesday/rest-controller-challenge/README.md","focused":false,"flexScale":1,"deserializer":"Pane"},"activePaneId":3,"deserializer":"PaneContainer","version":1},"fullScreen":false,"packagesWithActiveGrammars":["language-gfm","language-ruby","language-html","language-hyperlink","language-todo"],"deserializer":"Workspace"},"packageStates":{"fuzzy-finder":{"/Users/benfallon/Desktop/DBC/phase_2/week_4/wednesday/rest-controller-challenge/README.md":1445436391357},"metrics":{"sessionLength":282763465},"tabs":[{}],"tree-view":{"directoryExpansionStates":{"/Users/benfallon/Desktop/DBC/phase_2/week_4/wednesday/rest-controller-challenge":{"isExpanded":true,"entries":{".git":{"isExpanded":false,"entries":{}},"app":{"isExpanded":false,"entries":{}},"config":{"isExpanded":false,"entries":{}},"db":{"isExpanded":false,"entries":{}},"public":{"isExpanded":false,"entries":{}},"spec":{"isExpanded":false,"entries":{}}}}},"selectedPath":"/Users/benfallon/Desktop/DBC/phase_2/week_4/wednesday/rest-controller-challenge/README.md","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}